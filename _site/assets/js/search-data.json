{"0": {
    "doc": "Ch1 헬로 파이썬",
    "title": "Ch1 헬로 파이썬",
    "content": " ",
    "url": "http://localhost:4000/docs/deap-learning-from-scratch/ch1-hello-python/",
    "relUrl": "/docs/deap-learning-from-scratch/ch1-hello-python/"
  },"1": {
    "doc": "Ch1 헬로 파이썬",
    "title": "Table of contents",
    "content": ". | 1.4 파이썬 스크립트 파일 . | 1.4.2 클래스 . | 구조 | __init__ | 예제 | . | . | 1.5 넘파이 . | 1.5.1 넘파이 가져오기 | 1.5.2 넘파이 배열 생성하기 | 1.5.3 넘파이의 산술 연산 | 1.5.4 넘파이의 N차원 배열 | 1.5.5 브로드캐스트 | 1.5.6 원소 접근 | . | 1.6 matplotlib . | 1.6.1 단순한 그래프 그리기 | 1.6.2 pyplot의 기능 | 1.6.3 이미지 표시하기 | . | 1.7 정리 . | 후속 공부 | . | . ",
    "url": "http://localhost:4000/docs/deap-learning-from-scratch/ch1-hello-python/#table-of-contents",
    "relUrl": "/docs/deap-learning-from-scratch/ch1-hello-python/#table-of-contents"
  },"2": {
    "doc": "Ch1 헬로 파이썬",
    "title": "1.4 파이썬 스크립트 파일",
    "content": "1.4.2 클래스 . | 독자적인 자료형을 만들 수 있다. | 전용 함수(메서드)와 속성을 정의할 수 있다. | . 구조 . class 클래스 이름: def __init__(self, 인수, ...): # 생성자 ... def 메서드 이름 1(self, 인수, ...): # 메서드 1 ... def 메서드 이름 2(self, 인수, ...): # 메서드 2 ... __init__ . | 클래스를 초기화하는 방법을 정의한다. | 생성자라고도 한다. | 클래스의 인스턴스가 만들어질 때 한 번만 불린다. | 메서드의 첫 번째 인수로 자신(자신의 인스턴스)을 나타내는 self를 명시적으로 쓴다. | . 예제 . class Man: def __init__(self, name): self.name = name print(\"Initialized!\") def hello(self): print(\"Hello \" + self.name + \"!\") def goodbye(self): print(\"Good-bye \" + self.name + \"!\") m = Man(\"David\") m.hello() m.goodbye() . ",
    "url": "http://localhost:4000/docs/deap-learning-from-scratch/ch1-hello-python/#14-%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%ED%8C%8C%EC%9D%BC",
    "relUrl": "/docs/deap-learning-from-scratch/ch1-hello-python/#14-파이썬-스크립트-파일"
  },"3": {
    "doc": "Ch1 헬로 파이썬",
    "title": "1.5 넘파이",
    "content": ". | 넘파이의 배열 클래스 numpy.array에 배열과 행렬 계산에 편리한 메서드 많음 | . 1.5.1 넘파이 가져오기 . import numpy as np . 1.5.2 넘파이 배열 생성하기 . # interpreter import numpy as np x = np.array([1.0, 2.0, 3.0]) print(x) type(x) . | numpy.array : 리스트를 인수로 받아 넘파이 배열(numpy.ndarray)을 반환한다. | . 1.5.3 넘파이의 산술 연산 . # interpreter x = np.array([1.0, 2.0, 3.0]) y = np.array([2.0, 4.0, 6.0]) x + y x - y x * y x / y . | 원소별(element-wise) 산술연산 수행 . | 원소 수가 같을 때만 산술 연산할 수 있음 . | . 1.5.4 넘파이의 N차원 배열 . # interpreter A = np.array([[1, 2], [3, 4]]) print(A) A.shape A.dtype B = np.array([[3, 0], [0, 6]]) A + B A * B . | ndarray.shape : 배열의 형상 출력 . | ndarray.dtype : 배열의 원소의 자료형 출력 . | . | 1차원 배열 : 벡터(vector) . | 2차원 배열 : 행렬(matrix) . | 벡터와 행렬을 일반화한 것 : 텐서(tensor) . | . 1.5.5 브로드캐스트 . | 형상이 다른 배열끼리 산술연산할 수 있도록 하는 기능 . | 스칼라값과 n차원 배열의 산술연산에서 스칼라값을 n차원 배열로 확장한 후 연산 . | 저차원 배열과 고차원 배열의 산술연산에서 저차원 배열을 고차원 배열로 확장한 후 연산 . | . # interpreter A = np.array([[1, 2], [3, 4]]) B = np.array([10, 20]) A * 10 B * 10 A * B . 1.5.6 원소 접근 . # interpreter X = np.array([[51, 55], [14, 19], [0, 4]]) print(X) X[0] X[0][1] for row in X: print(row) . | 인덱스로 접근 | . X = X.flatten() # X를 1차원 배열로 변환(평탄화) print(X) X[np.array([0, 2, 4])] # 인덱스가 0, 2, 4인 원소 얻기 X &gt; 15 X[X&gt;15] . | 인덱스를 배열로 지정해 한 번에 여러 원소에 접근 . | 특정 조건을 만족하는 원소를 얻을 수 있다. | bool 배열을 사용해 True에 해당하는 원소에만 접근할 수 있다. | . 넘파이의 주된 처리는 C와 C++로 구현되어 성능을 해치지 않으면서 파이썬의 편리한 문법을 사용할 수 있다. ",
    "url": "http://localhost:4000/docs/deap-learning-from-scratch/ch1-hello-python/#15-%EB%84%98%ED%8C%8C%EC%9D%B4",
    "relUrl": "/docs/deap-learning-from-scratch/ch1-hello-python/#15-넘파이"
  },"4": {
    "doc": "Ch1 헬로 파이썬",
    "title": "1.6 matplotlib",
    "content": ". | 그래프 그리기와 데이터 시각화를 위한 라이브러리 | . 1.6.1 단순한 그래프 그리기 . %matplotlib tk import numpy as np import matplotlib.pyplot as plt # 데이터 준비 x = np.arange(0, 6, 0.1) # 0에서 6까지 0.1 간격으로 넘파이 배열 생성 y = np.sin(x) # 그래프 그리기 plt.plot(x, y) plt.show() . %matplotlib tk : tkinter UI에 그래프 출력하기 위한 magic command . | matplotlib.pyplot.plot : 그래프 그리기 . | matplotlib.pyplot.show : 그래프를 화면에 출력 . | . 1.6.2 pyplot의 기능 . %matplotlib tk import numpy as numpy import matplotlib.pyplot as plt # 데이터 준비 x = np.arange(0, 6, 0.1) # 0에서 6까지 0.1 간격으로 생성 y1 = np.sin(x) y2 = np.cos(x) # 그래프 그리기 plt.plot(x, y1, label=\"sin\") plt.plot(x, y2, linestyle=\"--\", label=\"cos\") # cos 함수 점선으로 그리기 plt.xlabel(\"x\") # x축 이름 plt.ylabel(\"y\") # y축 이름 plt.title('sin &amp; cos') # 제목 plt.legend() # 그래프 범례 표시 plt.show() . 1.6.3 이미지 표시하기 . import matplotlib.pyplot as plt from matplotlib.image import imread img = imread('/mnt/c/Users/dajin/Pictures/01 portrait/07 meenoi/6.jpg') # 이미지 읽어오기 plt.imshow(img) plt.show() . ",
    "url": "http://localhost:4000/docs/deap-learning-from-scratch/ch1-hello-python/#16-matplotlib",
    "relUrl": "/docs/deap-learning-from-scratch/ch1-hello-python/#16-matplotlib"
  },"5": {
    "doc": "Ch1 헬로 파이썬",
    "title": "1.7 정리",
    "content": "후속 공부 . | 처음 시작하는 파이썬(한빛미디어, 2015) . | 파이썬 프로그래밍을 기초부터 응용까지 친절하게 설명해주는 실천적인 입문서 | . | 파이썬 라이브러리를 활용한 데이터 분석(한빛미디어, 2013) . | 넘파이 | . | Scipy 강의 노트(웹사이트) . | 과학 기술에서의 계산을 주제로 넘파이와 matplotlib을 잘 설명함 | . | . ",
    "url": "http://localhost:4000/docs/deap-learning-from-scratch/ch1-hello-python/#17-%EC%A0%95%EB%A6%AC",
    "relUrl": "/docs/deap-learning-from-scratch/ch1-hello-python/#17-정리"
  },"6": {
    "doc": "Ch2 퍼셉트론",
    "title": "Ch2 퍼셉트론",
    "content": " ",
    "url": "http://localhost:4000/docs/deap-learning-from-scratch/ch2-perceptron/",
    "relUrl": "/docs/deap-learning-from-scratch/ch2-perceptron/"
  },"7": {
    "doc": "Ch2 퍼셉트론",
    "title": "Table of contents",
    "content": ". | 2.1 퍼셉트론이란 | 2.2 단순한 논리 회로 . | 2.2.1 AND 게이트 | 2.2.2 NAND 게이트와 OR 게이트 . | NAND 게이트 | OR 게이트 | . | . | 2.3 퍼셉트론 구현하기 . | 2.3.1 간단한 구현부터 . | AND 게이트 구현 | . | 2.3.2 가중치와 편향 도입 | 2.3.3 가중치와 편향 구현하기 . | 가중치와 편향을 도입한 AND 게이트 | NAND 게이트와 OR 게이트 구현 | . | . | 2.4 퍼셉트론의 한계 . | 2.4.1 XOR 게이트 | 2.4.2 선형과 비선형 | . | 2.5 다층 퍼셉트론이 출동한다면 . | 2.5.1 기존 게이트 조합하기 | 2.5.2 XOR 게이트 구현하기 | . | 2.6 NAND에서 컴퓨터까지 | 2.7 정리 . | 이번 장에서 배운 내용 | . | . | 프랑크 로젠블라트가 1957년에 고안한 알고리즘 . | 신경망(딥러닝)의 기원이 되는 알고리즘 . | . ",
    "url": "http://localhost:4000/docs/deap-learning-from-scratch/ch2-perceptron/#table-of-contents",
    "relUrl": "/docs/deap-learning-from-scratch/ch2-perceptron/#table-of-contents"
  },"8": {
    "doc": "Ch2 퍼셉트론",
    "title": "2.1 퍼셉트론이란",
    "content": ". | 다수의 신호를 입력으로 받아 하나의 신호를 출력 . | 0과 1 두 가지 값을 가짐 . | . flowchart LR x1((x1)); x2((x2)); y((y)) x1 --w1--&gt;y x2 --w2--&gt;y . | $x_1$, $x_2$는 입력 신호, $y$는 출력 신호, $w_1$, $w_2$는 가중치 . | 위의 원을 뉴런 혹은 노드라고 부름 . | 입력 신호가 뉴런에 보내질 때는 각각 고유한 가중치(weight)가 곱해짐($w_1x_1, w_2x_2$) . | 뉴런에서 보내온 신호의 총합이 정해진 한계를 넘어설 때만 1 출력 . | 뉴런이 활성화한다고 표현하기도 함 . | 한계를 임계값이라고 하며 $\\theta$로 나타냄 . | . | . $$ y = \\begin{cases} 0~(w_1x_1 + w_2x_2 \\le \\theta)\\\\ 1~(w_1x_1 + w_2x_2 &gt; \\theta) \\end{cases} $$ ",
    "url": "http://localhost:4000/docs/deap-learning-from-scratch/ch2-perceptron/#21-%ED%8D%BC%EC%85%89%ED%8A%B8%EB%A1%A0%EC%9D%B4%EB%9E%80",
    "relUrl": "/docs/deap-learning-from-scratch/ch2-perceptron/#21-퍼셉트론이란"
  },"9": {
    "doc": "Ch2 퍼셉트론",
    "title": "2.2 단순한 논리 회로",
    "content": ". | 퍼셉트론을 표현하기 위해서는 퍼셉트론의 매개변수인 가중치와 임계값을 결정해야 한다. | . 2.2.1 AND 게이트 . | x1 | x2 | y | . | 0 | 0 | 0 | . | 1 | 0 | 0 | . | 0 | 1 | 0 | . | 1 | 1 | 1 | . | $(w_1, w_2, \\theta) = (0.5, 0.5, 0.7), (1.0, 1.0, 2.0), …$ 무수히 많음 | . 2.2.2 NAND 게이트와 OR 게이트 . NAND 게이트 . | x1 | x2 | y | . | 0 | 0 | 1 | . | 1 | 0 | 1 | . | 0 | 1 | 1 | . | 1 | 1 | 0 | . | $(w_1, w_2, \\theta) = (-0.5, -0.5, -0.7), …$ 무수히 많음 . | AND 게이트를 구현하는 매개변수의 부호를 반전하면 NAND 게이트가 된다. | . OR 게이트 . | x1 | x2 | y | . | 0 | 0 | 0 | . | 1 | 0 | 1 | . | 0 | 1 | 1 | . | 1 | 1 | 1 | . | $(w_1, w_2, \\theta) = (1.0, 1.0, 1.0), …$ 무수히 많음 | . 학습이란 적절한 매개변수 값을 정하는 작업이다. 여기서는 인간이 진리표라는 학습데이터를 보면서 매개변수의 값을 결정했지만 기계학습에서는 컴퓨터가 학습데이터를 보고 자동으로 학습한다. 사람은 퍼셉트론의 구조(모델)을 고민하고 컴퓨터에 학습할 데이터를 주는 일을 한다. | 퍼셉트론의 구조는 AND, NAND, OR 게이트에서 모두 똑같다. | 같은 구조의 퍼셉트론에서 매개변수의 값만 적절히 조정하면 AND, NAND, OR이 된다. | . ",
    "url": "http://localhost:4000/docs/deap-learning-from-scratch/ch2-perceptron/#22-%EB%8B%A8%EC%88%9C%ED%95%9C-%EB%85%BC%EB%A6%AC-%ED%9A%8C%EB%A1%9C",
    "relUrl": "/docs/deap-learning-from-scratch/ch2-perceptron/#22-단순한-논리-회로"
  },"10": {
    "doc": "Ch2 퍼셉트론",
    "title": "2.3 퍼셉트론 구현하기",
    "content": "2.3.1 간단한 구현부터 . AND 게이트 구현 . def AND(x1, x2): w1, w2, theta = 0.5, 0.5, 0.7 tmp = x1*w1 + x2*w2 if tmp &lt;= theta: return 0 if tmp &gt;= theta: return 1 . # interpreter AND(0, 0) AND(1, 0) AND(0, 1) AND(1, 1) . 2.3.2 가중치와 편향 도입 . $$ y = \\begin{cases} 0~(w_1x_1 + w_2x_2 \\le \\theta)\\\\ 1~(w_1x_1 + w_2x_2 &gt; \\theta)\\\\ \\end{cases} $$ $\\theta = -b$ 치환 . $$ y = \\begin{cases} 0~(b + w_1x_1 + w_2x_2 \\le 0)\\\\ 1~(b + w_1x_1 + w_2x_2 &gt; 0)\\\\ \\end{cases} $$ . | $b$를 편향(bias)이라고 한다. | . # interpreter import numpy as np x = np.array([0, 1]) # 입력 w = np.array([0.5, 0.5]) # 가중치 b = -0.7 # 편향 w*x np.sum(w*x) + b . | 넘파이 배열끼리의 곱셈은 원소 수가 같다면 각 원소끼리 곱한다. | np.sum() : 입력한 배열에 담긴 모든 원소의 총합 계산 . | . 2.3.3 가중치와 편향 구현하기 . 가중치와 편향을 도입한 AND 게이트 . import numpy as np def AND(x1, x2): x = np.array([x1, x2]) w = np.array([0.5, 0.5]) b = -0.7 tmp = np.sum(w*x) + b if tmp &lt;= 0: return 0 else: return 1 . # interpreter AND(0, 0) AND(1, 0) AND(0, 1) AND(1, 1) . | 가중치와 편향은 기능이 다르다는 사실에 주의! . | 가중치는 각 입력 신호가 결과에 주는 영향력(중요도)을 조절하는 매개변수 . | 편향은 뉴런이 얼마나 쉽게 활성화(결과로 1을 출력)하느냐를 조정하는 매개변수 . | . | $w_1$과 $w_2$는 가중치로, $b$는 편향으로 서로 구별하기도 하지만 문맥에 따라 셋 모두를 가중치라고 할 때도 있다. | . 편향이라는 용어는 ‘한쪽으로 치우쳐 균형을 깬다’라는 의미를 담고 있다. 실제로 두 입력이 모두 0이어도 결과로 편향 값을 출력한다. NAND 게이트와 OR 게이트 구현 . import numpy as np def NAND(x1, x2): x = np.array([x1, x2]) w = np.array([-0.5, -0.5]) b = 0.7 tmp = np.sum(w*x) + b if tmp &lt;= 0: return 0 else: return 1 def OR(x1, x2): x = np.array([x1, x2]) w = np.array([0.5, 0.5]) b = -0.2 tmp = np.sum(w*x) + b if tmp &lt;= 0: return 0 else: return 1 . # interpreter NAND(0, 0) NAND(1, 0) NAND(0, 1) NAND(1, 1) OR(0, 0) OR(1, 0) OR(0, 1) OR(1, 1) . ",
    "url": "http://localhost:4000/docs/deap-learning-from-scratch/ch2-perceptron/#23-%ED%8D%BC%EC%85%89%ED%8A%B8%EB%A1%A0-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0",
    "relUrl": "/docs/deap-learning-from-scratch/ch2-perceptron/#23-퍼셉트론-구현하기"
  },"11": {
    "doc": "Ch2 퍼셉트론",
    "title": "2.4 퍼셉트론의 한계",
    "content": ". | 단층 퍼셉트론으로는 XOR 게이트를 표현할 수 없음 . | 단층 퍼셉트론으로는 비선형 영역을 분리할 수 없음 . | . 2.4.1 XOR 게이트 . | x1 | x2 | y | . | 0 | 0 | 0 | . | 1 | 0 | 1 | . | 0 | 1 | 1 | . | 1 | 1 | 0 | . | 직선 하나로 $\\bigcirc$와 $\\triangle$을 나눌 수 없다. | . 2.4.2 선형과 비선형 . | 곡선이라면 $\\bigcirc$와 $\\triangle$을 나눌 수 있다. | 곡선의 영역을 비선형 영역, 직선의 영역을 선형 영역이라고 함 . | 퍼셉트론은 직선 하나로 나눈 영역만 표현할 수 있다는 한계가 있음 . | . ",
    "url": "http://localhost:4000/docs/deap-learning-from-scratch/ch2-perceptron/#24-%ED%8D%BC%EC%85%89%ED%8A%B8%EB%A1%A0%EC%9D%98-%ED%95%9C%EA%B3%84",
    "relUrl": "/docs/deap-learning-from-scratch/ch2-perceptron/#24-퍼셉트론의-한계"
  },"12": {
    "doc": "Ch2 퍼셉트론",
    "title": "2.5 다층 퍼셉트론이 출동한다면",
    "content": ". | 다층 퍼셉트론을 이용해서 XOR 표현 | . 2.5.1 기존 게이트 조합하기 . | AND, NAND, OR 게이트를 조합 | . | x1 | x2 | s1 | s2 | y | . | 0 | 0 | 1 | 0 | 0 | . | 1 | 0 | 1 | 1 | 1 | . | 0 | 1 | 1 | 1 | 1 | . | 1 | 1 | 0 | 1 | 0 | . 2.5.2 XOR 게이트 구현하기 . def XOR(x1, x2): s1 = NAND(x1, x2) s2 = OR(x1, x2) y = AND(s1, s2) return y . # interpreter XOR(0, 0) XOR(1, 0) XOR(0, 1) XOR(1, 1) . | 뉴런을 이용한 퍼셉트론으로 표현 | . flowchart LR x1((x1)); x2((x2)); s1((s1)); s2((s2)); y((y)) x1 --&gt; s1; x1 --&gt; s2 x2 --&gt; s1; x2 --&gt; s2 s1 --&gt; y s2 --&gt; y subgraph f0[0층] x1; x2 end subgraph f1[1층] s1; s2 end subgraph f2[2층] y end . | 이처럼 층이 여러 개인 퍼셉트론을 다층 퍼셉트론이라고 한다. | 층을 쌓아 퍼셉트론으로 다양한 것을 표현할 수 있음 . | . 위의 퍼셉트론은 총 3층으로 구성되지만 가중치를 갖는 층은 2개 뿐이므로 2층 퍼셉트론이라 부르기로 하자. 3층 퍼셉트론이라 하는 경우도 있다. ",
    "url": "http://localhost:4000/docs/deap-learning-from-scratch/ch2-perceptron/#25-%EB%8B%A4%EC%B8%B5-%ED%8D%BC%EC%85%89%ED%8A%B8%EB%A1%A0%EC%9D%B4-%EC%B6%9C%EB%8F%99%ED%95%9C%EB%8B%A4%EB%A9%B4",
    "relUrl": "/docs/deap-learning-from-scratch/ch2-perceptron/#25-다층-퍼셉트론이-출동한다면"
  },"13": {
    "doc": "Ch2 퍼셉트론",
    "title": "2.6 NAND에서 컴퓨터까지",
    "content": ". | NAND 게이트만으로 컴퓨터 제작 가능 $\\rightarrow$ 퍼셉트론으로 컴퓨터 제작 가능 . | 퍼셉트론은 층을 거듭 쌓으면 비선형적인 표현도 가능하고 이론상 컴퓨터가 수행하는 처리도 표현 가능 . | . ",
    "url": "http://localhost:4000/docs/deap-learning-from-scratch/ch2-perceptron/#26-nand%EC%97%90%EC%84%9C-%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B9%8C%EC%A7%80",
    "relUrl": "/docs/deap-learning-from-scratch/ch2-perceptron/#26-nand에서-컴퓨터까지"
  },"14": {
    "doc": "Ch2 퍼셉트론",
    "title": "2.7 정리",
    "content": "이번 장에서 배운 내용 . | 퍼셉트론은 입출력을 갖춘 알고리즘이다. 입력을 주면 정해진 규칙에 따른 값을 출력한다. | 퍼셉트론에서는 가중치와 편향을 매개변수로 설정한다. | 퍼셉트론으로 AND, OR 게이트 등의 논리 회로를 표현할 수 있다. | XOR 게이트는 단층 퍼셉트론으로는 표현할 수 없다. | 2층 퍼셉트론을 이용하면 XOR 게이트를 표현할 수 있다. | 단층 퍼셉트론은 직선형 영역만 표현할 수 있고, 다층 퍼셉트론으 ㄴ비선형 영영역도 표현할 수 있다. | 다층 퍼셉트론은 (이론상) 컴퓨터를 표현할 수 있다. | . ",
    "url": "http://localhost:4000/docs/deap-learning-from-scratch/ch2-perceptron/#27-%EC%A0%95%EB%A6%AC",
    "relUrl": "/docs/deap-learning-from-scratch/ch2-perceptron/#27-정리"
  },"15": {
    "doc": "Deap Learning from Scratch",
    "title": "Deap Learning from Scratch",
    "content": "deap learning from scratch . ",
    "url": "http://localhost:4000/docs/deap-learning-from-scratch",
    "relUrl": "/docs/deap-learning-from-scratch"
  },"16": {
    "doc": "Home",
    "title": "rewls",
    "content": "study . Github Blog . ",
    "url": "http://localhost:4000/#rewls",
    "relUrl": "/#rewls"
  },"17": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "http://localhost:4000/",
    "relUrl": "/"
  },"18": {
    "doc": "Test",
    "title": "test",
    "content": "test . ",
    "url": "http://localhost:4000/docs/test#test",
    "relUrl": "/docs/test#test"
  },"19": {
    "doc": "Test",
    "title": "Test",
    "content": " ",
    "url": "http://localhost:4000/docs/test",
    "relUrl": "/docs/test"
  }
}
